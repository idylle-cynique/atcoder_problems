# ARC099 - A

# 1~Nまでの数からなる等差数列を入れ替えたものである、と示されていることから
# 最終的には数列要素をすべて1にすることを目指すものである、ということが判る
# したがって、値が1である要素のインデックスを取得し、そこの両隣から最小化処理(K-1個ずつ1にしていく)を行っていく
# しかし、これでは N=10, K=4 A=[3,2,1,4,7,6,5,8,9,10]のようなとき
# [1,1,1,1,7,6,5,8,9,10]→[1,1,1,1,1,1,1,8,9,10]→[1,1,1,1,1,1,1,1,1,1]で3回が解となるところが
# [1,1,1,4,7,6,5,8,9,10]→[1,1,1,1,1,1,5,8,9,10]→[1,1,1,1,1,1,1,1,1,10]→[1,1,1,1,1,1,1,1,1,1]で4回となってしまう

# これを避けるために最大効率での最小化処理(K-1個の要素の最小か)が行えない場合は余り要素として記録し
# 両端に発生した余り要素の総数に応じて、処理階数を補正。これでようやく正しい解が得られる

N,K = map(int,input().split())
A = [int(x) for x in input().split()]

min_idx = A.index(1) # 値が1である要素のインデックスを取得
l_len = min_idx             # 最小値の左側にある要素の個数 
r_len = len(A)-min_idx-1    # 最小値の右側にある要素の個数

l_time = l_len//(K-1)       # 左側の最小化に必要な処理回数(余り除く) 
r_time = r_len//(K-1)       # 右側の最小化に必要な処理回数(余り除く)
mod = (l_len%(K-1) + r_len%(K-1)) # 発生した両端の余り要素の個数を得る
times = l_time + r_time     # ベースとなる必要処理回数 

#print("left:",l_len,"right:",r_len); print("times:",times); print("mod:",mod)

if mod == 0:        # 余りが発生しなかった場合、回数の補正は必要ない
    times += 0
elif mod <= (K-1):  # 余りが(K-1)個以下なら、処理開始位置を補正すれば1回分の追加処理で処理を完了できる  
    times += 1
else:               # 余りが(K-1)個超なら、どうやっても2回分の追加処理が必要となる
    times += 2

print(times)