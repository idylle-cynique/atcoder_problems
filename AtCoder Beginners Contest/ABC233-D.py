# ABC233 - D

'''
    区間和の数え上げ問題
    区間和の解法としては、尺取り法・累積和などが挙げられるが、ここでは累積和と+αの発想が求められる
    正数のみ、あるいは負数のみの場合などであれば尺取り法が利用できるのだが、正数と負数の両方を含むため
    尺取り法では正しく条件を満たす区間を特定することができない

    たとえば、A = [4, -6, -6, 12] K = 4 のような場合、
    尺取り法では(1,4)の区間で K=4 となるような場合を取り挙げることができない

    したがって、尺取り法のように条件を満たす区間の幅を当てつけるようなやり方ではなく、
    累積和でいかなる連続区間和もO(1)で求められるように下準備を行い、
    これを上手く工夫して探索できるように考えなくてはならない

    累積和リストを B とした場合、区間(l,r)における連続区間和は
    B[r] - B[l]であり、B[r] - B[l] = K であるような区間を探すことになる
    r,lのインデックスの二重ループでは(10^5)^2 = 10^10ものループが発生するので計算が間に合わない
    そこで、右端の位置だけ固定してみる。
    
    右端(r)を固定した場合、0～B[r]までの累積和からKを超過する分だけ0～B[l]までの累積和を用いて取り除きたい
    これを実現出来る区間の数は、 B[r] - K = B[l] を満たす左端(l)の数で、右端よりも左側にある場合(l<r)ということになる
    この部分を辞書型リスト(連想配列)を用いて右端のループを行いながら
    並行して左端として使える累積和要素を数え上げ、順次それを利用していくことによって、
    l部分のループを取り除くことができる

    以上によって計算は右端インデックスのループのみで済み、全体としての計算量はO(N)あるいはO(N・logN)となる
'''

import itertools

N,K = map(int,input().split())
A = [int(x) for x in input().split()]
B = list(itertools.accumulate(A)) # Aの累積和リスト
B_Dict = {0:1} # (0,0)という区間も存在しうる

cnt = 0

for r in range(N):
    key = B[r] - K # Kを超過する分
    #print(B[r],"rest:",B[r]-K); print(B_Dict)
    if key in B_Dict:  # 超過分をこれまでの累積和要素で補正できるとき
        cnt += B_Dict[key]
    else:              # 補正できないとき
        pass
    
    if B[r] in B_Dict: # 今回右端として使った累積和の要素を辞書に加え入れる
        B_Dict[B[r]] += 1
    else:
        B_Dict[B[r]] = 1

print(cnt)