''' ABC262 - C
    処理そのものは明白だが、数列の要素数が最大5×10^5なので二重ループなどによる愚直な全探索はできない
    何かしらの工夫をしてO(N・logN)程度で処理を実現できるようにしたい

    この問題の場合、サンプル入出力例などを手作業で解いてみると容易に気づくことができるが
    条件を満たす整数の組はごく限られていて、かつその内容もかなり単純
    具体的には
        i)  a_i = i であるような要素と a_j = j であるような要素の組
        ii) a_i = j であるような要素と a_j = i であるような要素の組
    がこの問題における数え上げ対象となる組み合わせである

    つまり、ある要素に対する条件を満たす他の要素は、全探索せずとも容易に求めることができる
    具体的には以下の通り
        i)の場合
            a_i = i という条件を満たす要素だけを抜き出した数列から2つ選んだ時の組み合わせの数
            この時の数列の長さをLとするなら、このときの条件を満たす組み合わせの数はL*(L-1)//2
        ii)の場合
            a_j = i(a_i = j) という条件を満たす要素に対応する値は常に一つしか存在しないので、
            この条件を満たす要素のみを抜きだ出した数列(コンテナ)を用意し、それを線形探索して
            対応する要素の存在をひとつずつチェックしていけばよい
    
    以上の処理を行うまでに必要なのは結局
        1) N個の要素のふるい分け O(N)
        2) ふるい分けた要素のうち、i)の数列のうち条件を満たす要素の計算 O(1)
        3) ふるい分けた要素のうち、ii)の数列を線形探索して条件を満たす要素の数え上げ O(N)
    の3つで、全体での計算量はO(N)
'''

N = int(input())
Numbers = [int(x) for x in input().split()]
Group1 = list()
Group2 = dict()
answer = 0
cnt = 0

for i,a in enumerate(Numbers):
    i += 1
    if i != a:
        Group2[i] = a
    else:
        Group1.append(a)

answer += (len(Group1)*(len(Group1)-1)//2)

for key,val in Group2.items():
    if val not in Group2:
        continue
    
    if Group2[val] == key:
        cnt += 1
        
answer += (cnt//2)

print(answer)