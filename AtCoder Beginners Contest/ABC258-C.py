''' ABC258 - C
    問題中の処理「末尾の要素を取り出して先頭に挿入」などから
    キューなどのデータ構造の利用を求める問題のように見えるがそうではない

    確かに先頭への挿入処理がO(1)を用いればクエリ1の処理はリスト(配列)より断然高速に処理できるが
    それでも最大10^5回発生するN回のクエリで、それぞれ最大10^5回発生する先頭への挿入処理をまともに行うと
    最大で10^10回もの処理が発生してしまい、処理が間に合わない
    もっと違う視点で問題の処理を考える必要がある

    クエリの処理をあらためて見直してみると、ここでの処理は実際に削除・挿入処理を行わなくても、
    クエリの数値情報をもとに「与えられた文字列中で現在どの位置が先頭あたるのか」
    だけを把握しておくだけで全て完結可能なものであることがわかる

    したがって、
    クエリ1では文字列中の現在先頭位置に対応する値を計算によって求めるだけに留め、データそのものに変更処理は加えない
    クエリ2では現在保持している先頭位置の情報をベースに先頭からx番目の要素を求め出力する
    という具合にすることで、各クエリの処理がO(1)で完結し、全体での計算量もクエリ分だけ、すなわちO(N)で抑えられる
'''

N,Q = map(int,input().split())
queue = list(input())
length = len(queue)
start_idx = int(0)

for i in range(Q):
    t,x = map(int,input().split())
    #print(t,x,"->",start_idx)
    if t == 1:
        start_idx = (N-x + start_idx)%length
    elif t == 2:
        pos = ((N + start_idx + x)%N) - 1
        #print(N,x,start_idx)
        print(queue[pos])