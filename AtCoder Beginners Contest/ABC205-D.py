# ABC205 - D

'''
    二分探索アルゴリズムの実装(利用)を求める問題
    単に一個のクエリを処理するだけであれば、問題で要求されている処理は数列の線形探索によって実装できるが、
    最大10^5個ものクエリを処理するとなると計算量はO(N・Q)で、最大10^10回ものループ処理が発生してしまう

    数列中のi番目の要素までに存在する「いずれとも異なる正整数の個数」のリストは、当然ながら広義単調増加で、
    与えられた値(k)番目の値が数列中のどの位置に存在し、それまでに「数列中のいずれとも異なる正整数の個数」は
    二分探索によって行うことができる。これを利用すると、一回のクエリへの処理で必要な計算はO(N)からO(logN)
    となり、全体としての計算量も(N + Q・logN)にまで抑えることが出来る
'''

import bisect

N,Q = map(int,input().split())
A = [0] + [int(x) for x in input().split()]
B = [0]

for i in range(1,N+1): # A[i]までに存在する数列Aのいずれとも異なる正整数の個数のリストを生成
    B.append(B[-1]+(A[i]-A[i-1]-1))

#print(A); print(B)

for i in range(Q):
    k = int(input()) # クエリを取得
    idx = bisect.bisect_left(B,k)   # k個の値は数列中のどの位置に存在するかを二分探索でチェックする

    # k番目の値は、k番目の値未満の数で一番近い数列要素(A[idx-1])からそれまでに存在する要素の個数を差し引いた分(k - B[idx-1])となる
    print(A[idx-1] + (k-B[idx-1]))  