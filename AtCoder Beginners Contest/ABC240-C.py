# ABC240 - C

'''
    2通りあるパターンのいずれかを選んでいって条件を満たすものを選ぶ……
    というところではbit全探索アルゴリズムが思い浮かぶが、
    最大で100回の2分岐を全パターン試すとなると2^100ものループ処理が発生する
    これでは到底処理が間に合わないので、違う形での探索を試みる必要がある

    制約に着目していくと、
        1)「ジャンプ回数は最大100回までで、N=100のとき”100回ちょうどでXになる”必要がある
        2)「一度にジャンプ可能な距離も同様に最大で100まで」
    とある。これを整理すると「ジャンプ処理を行って到達可能なのは最大でも10000の地点まで」
    であることが分かる。
    また、ジャンプ処理によって到達可能な座標を考えてみると
        A = [3,2,3]
        B = [4,1,2]
    のような場合、3番目までで到達可能なのは{6,7,8,9}と、値が重複して2^3よりも
    大幅に少ないことが分かる。
    つまり、「i番目にA,Bのいずれかを選んだ時」で探索するのではなく
    「i番目までで到達できる座標は何か」を重複を避けて探索すれば
    探索数を多めに見積もっても100×10000 = 10^2+10^5 = 10^7程度の 
    ループ処理で探索を終えることができ、探索を終えた時点到達可能な座標位置に
    Xが含まれていればYes, 含まれていなければNo であるということができる

    このコードでは_番目で到達可能な座標位置をset()を用いて重複なく探索し
    それを更新していくことでN番目でXに到達できるか否か、を求めている

    このほか「i番目のジャンプ処理を用いて座標jに行くことは可能か」という形で
    100×10000のDPテーブルを作成し、動的計画法によって解を求める方法もあるが
    基本的な方針はいずれでも同じ
'''

N,X = map(int,input().split())
A = []
B = []
AllPatterns = set([0])

for _ in range(N):
    a,b = map(int,input().split())
    A.append(a)
    B.append(b)
    
for i in range(N):
    #print(A[i],B[i]);print(AllPatterns)
    temp_set = set()
    
    for ele in AllPatterns:
        temp_set.add(ele+A[i])
        temp_set.add(ele+B[i])
    
    AllPatterns = temp_set
#print(AllPatterns)

if X in AllPatterns:
    print("Yes")
else:
    print("No")