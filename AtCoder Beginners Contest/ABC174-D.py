# ABC174 - D

# 問題の解答となるような石の並びとは一体何なのか、というのを考えてみると
# 左半分に赤い石、右半分に白い石がまとまって並ぶ並び、もしくは全てが赤い石か白い石のいずれかで構成される並び
# であると想起できる。ただ、そのうちのどれを目指すのが最適なのかを事前に判断するのは難しいので、
# それらを全てチェックしたうえで、必要処理回数が少なくなるものを出力することにする

from collections import Counter

N = int(input())
S = list(input())

# 赤い石の左隣に白い石がないようにする
# 1) 石を 2個選び (隣り合っていなくてもよい)、それらを入れ替える。
# 2) 石を 1個選び、その石の色を変える (赤なら白に、白なら赤に)。
# 最終的には, RRWWW, WWWWW, RRRRR といった具合にしたい

cnt = 0 # 入れ替え処理時の処理回数の数え上げ
S_counter = Counter(S) # Counterで赤い石と白い石の数を数え上げ
l,r = 0,N-1
#print(S_counter)

while(l <= r): #REコードを修正
    #print(l,S[l],"-",r,S[r],S,":",cnt) # デバッグ出力
    if S[l] != "W": # 白い石が見つかるまで左から線形探索
        l += 1
        continue
    
    if S[r] != "R": # 赤い石が見つかるまで右から線形探索
        r -= 1
        continue
    
    if S[l] == "W" and S[r] == "R": # 左に白い石、右に赤い石が見つかったら、二つを入れ替える
        S[l],S[r] = S[r],S[l]
        cnt += 1

# MIN(赤い石をすべて白い石に変えたとき、白い石をすべて赤い石に変えたとき、入れ替え処理を行ったとき)
ans = min(S_counter["W"],S_counter["R"],cnt)
print(ans)