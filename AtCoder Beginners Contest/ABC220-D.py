''' ABC220 - D
    問題文自体に書かれているように、ここでの処理を実際に再現していくと1度の処理ごとに2パターンの状態遷移が発生し
    最終的には数列の長さ乗(2^N-1)分だけの状態が発生する

    単純に探索するだけなら幅優先探索、深さ優先探索などのアルゴリズムを用いれば全探索することができるが、
    ここでの数列の長さは最大で10^5と大きいので、最大で2^(10^5)という極めて膨大な計算が必要となってしまう
    このように全探索は不可能なので、問題の処理に着目しつつ上手く全パターンの状態数を数え上げられる方法を考える必要がある

    問題での処理F, Gの内容に着目してみると、最終的にはどちらの処理も10の余りを取る処理を施すので処理碁に得られる値は常に
    0～9までの10通りしかないことがわかる
    また、ある位置におけるF,Gの処理結果は、それまでに行った事前の処理結果のみによって確定することもわかる

    N番目の処理結果をN-1番目の処理結果から求める。すなわち、動的計画法が有効な問題ということになる
    ここでは
        i番目まで処理を施し、その結果先頭の要素がjとなっているときの場合の数を記録できるDPテーブル
    を用意し、i+1番目の先頭要素の状態を計算後、それを対応するテーブル位置に配っていくことで最後のテーブル中の最後の行に
    問題の解が収まるようにしている

    また、場合の数は非常に大きくなるので、都度指定されたMOD値で余りをとりそれをテーブルに格納するようにすること
'''

N = int(input())
number = [int(x) for x in input().split()]
dp = [[0 for x in range(10)] for y in range(N)]
MOD = 998244353

def print_2dlist(lst):
    for row in lst: print(row)

dp[0][number[0]] = 1

for i in range(N-1):
    for j in range(10):
        #print(f"{i+1}番目までの要素に処理を施し、先頭の要素が{j}となっているとき")
        dp[i+1][(j + number[i+1])%10] += dp[i][j]
        dp[i+1][(j * number[i+1])%10] += dp[i][j]
        dp[i+1][(j + number[i+1])%10] %= MOD
        dp[i+1][(j * number[i+1])%10] %= MOD

#print_2dlist(dp)
for i in range(10):
    print(dp[-1][i])
